# Using the New ClickHouse `JSON` Type

**Purpose:**
Teach agents how to land and query semi-structured data using ClickHouse’s `JSON` type without sacrificing OLAP performance.

---

## 1. Principle

**Schema = Query Plan.**
Use the `JSON` type for evolving or irregular structures, but **type the hot paths** you query often.
Undeclared paths remain dynamic and flexible — but slower to scan.

---

## 2. Patterns of Use

| Use Case                         | Recommended Shape | Notes                                 |
| -------------------------------- | ----------------- | ------------------------------------- |
| Predictable nested arrays        | `Nested(...)`     | For fixed structure, compact and fast |
| Evolving keys or irregular shape | `JSON(...)`       | For semi-structured data              |
| One-off payload storage          | `String`          | For archival only, not queries        |

---

## 3. Declaring a JSON Column

Explicitly type stable paths, leave the rest dynamic:

```sql
CREATE TABLE orders
(
  order_id String,
  created_at DateTime,
  line_items JSON(
    sku String,
    quantity UInt8,
    price Decimal(10,2)
    -- details.* remain dynamic
  )
)
ENGINE = MergeTree
ORDER BY (created_at);
```

### Under the hood

Each declared path becomes a typed subcolumn:

```
line_items.sku       Array(Nullable(String))
line_items.quantity  Array(Nullable(UInt8))
line_items.price     Array(Nullable(Decimal(10,2)))
```

Dynamic paths (undeclared ones) appear as `Array(JSON)`.

---

## 4. Ingestion

```sql
INSERT INTO orders FORMAT JSONEachRow
{ "order_id": "ORD-1001",
  "created_at": "2025-10-08T10:30:00Z",
  "line_items": [
    {"sku":"SKU-001","quantity":1,"price":19.99,"details":{"name":"Wireless Mouse","average_rating":4.2}},
    {"sku":"SKU-002","quantity":2,"price":34.99,"details":{"name":"Keyboard"}}
  ]
}
```

ClickHouse auto-creates subcolumns on first ingestion of new keys (up to 1024 per column by default).

---

## 5. Querying JSON Subcolumns

### Read typed subcolumns directly

```sql
SELECT
  order_id,
  line_items.sku,
  line_items.quantity,
  line_items.price
FROM orders;
```

| order_id   | line_items.sku          | line_items.quantity |
| ---------- | ----------------------- | ------------------- |
| `ORD-1001` | `['SKU-001','SKU-002']` | `[1,2]`             |

### Access dynamic paths (on demand)

```sql
SELECT
  order_id,
  CAST(line_items.details.average_rating AS Array(Nullable(Float32))) AS ratings
FROM orders;
```

| order_id   | ratings       |
| ---------- | ------------- |
| `ORD-1001` | `[4.2, NULL]` |

---

## 6. Exploding Arrays (`ARRAY JOIN`)

```sql
SELECT
  order_id,
  sku, quantity, price
FROM orders
ARRAY JOIN
  line_items.sku AS sku,
  line_items.quantity AS quantity,
  line_items.price AS price;
```

---

## 7. Handling NULLs

JSON subcolumns are **implicitly nullable** to allow missing keys or type mismatches.
Use `ifNull()` or `coalesce()` to handle them safely:

```sql
SELECT
  order_id,
  arraySum(arrayMap((q,p)->ifNull(q,0)*ifNull(p,0),
                    line_items.quantity, line_items.price)) AS subtotal
FROM orders;
```

---

## 8. Performance Rules

| Path Type                                | Storage        | Behavior             | Speed  |
| ---------------------------------------- | -------------- | -------------------- | ------ |
| **Explicit typed** (`sku`, `price`)      | Columnar files | Typed and compressed | Fast   |
| **Implicit inferred** (`details.rating`) | Generic JSON   | Typed on read        | Medium |
| **Raw JSON blob**                        | Text blob      | Parsed per row       | Slow   |

---

## 9. Logging Example

For event logs or telemetry, use a shared envelope + `JSON` payload.
Type only the fields you query often:

```sql
CREATE TABLE device_events (
  ts DateTime64(3,'UTC'),
  device_id String,
  event_type LowCardinality(String),
  data JSON,
  cpu Float32 MATERIALIZED data.cpu:Float32,
  reason LowCardinality(Nullable(String)) MATERIALIZED data.reason:String
)
ENGINE = MergeTree
ORDER BY (event_type, device_id, ts);
```

Fast query:

```sql
SELECT reason, count()
FROM device_events
WHERE event_type = 'reboot'
GROUP BY reason
ORDER BY count() DESC;
```

---

## 10. Heuristics

1. **Type what you filter, group, or order by.**
2. **Let ClickHouse infer** irregular or evolving paths.
3. **Avoid per-row JSON parsing** in hot queries.
4. **Promote hot paths** to real columns when they stabilize.
5. **Keep ingestion simple:** one JSON payload, typed subcolumns for structure.

---

## 11. Path Limit Configuration

* Default dynamic path cap: `1024` per column
* Adjust with `SETTINGS max_dynamic_paths=N`
* Exceeding the limit skips new subcolumns (values stored as raw JSON only)

---

## 12. Quick Summary

**Use `JSON(...)` when:**

* Schema evolves frequently
* Only a few paths are queried regularly
* You want OLAP-style reads without rigid ETL

**Avoid using plain `String` for JSON unless you never query it.**
